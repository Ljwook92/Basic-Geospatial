[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Basic Geospatial",
    "section": "",
    "text": "1 Introduction\n\n지리공간 분석에는 주로 Python, QGIS, C, JAVA 등의 프로그램이 활용되지만, R 프로그램 또한 통계 기반의 강점을 바탕으로 유용한 도구로 평가된다. 본 분석에서는 R 프로그램을 이용한 지리공간 분석의 기초를 수행하고자 하며, R을 사용하는 데에는 다음과 같은 장점이 있다.\n\n통합 개발환경(IDE)을 통해 접근성이 뛰어나다.\n다양한 통계 패키지를 쉽게 적용할 수 있어 정량적 분석에 유리하다.\nggplot2와 같은 강력한 시각화 패키지를 통해 지리공간 데이터를 \b효과적으로 표현할 수 있다.\nRcpp, reticulate 등을 통해 C++과 Python의 기능을 통합적으로 활용할 수 있는 확장성을 갖고 있다.\n지리 연산 학습 및 계산 작업, 특히 통계, 모델링 및 시각화에 강력하다.\n\n다음은 R에서 대화형 지도제작 또한 가능하다는 것을 보여준다.\n\nlibrary(leaflet)\n\npopup = c(\"Seoul\", \"Tokyo\", \"Beijing\")\nleaflet() |&gt;\n  addProviderTiles(\"NASAGIBS.ViirsEarthAtNight2012\") |&gt; \n  addMarkers(lng = c(126.9780, 139.6917, 116.4074),\n             lat = c(37.5665, 35.6895, 39.9042),\n             popup = popup)\n\n\n\n\n\n\n\n2 Environment\n실습의 권장 사항은 R 버전 4.3.2 이상 버전.\n필수 패키지는 아래와 같다.\n# for \ninstall.packages(\"sf\")    # for vector data (points, lines, polygons)\ninstall.packages(\"terra\") # for raster data\n\n# for geographic data\ninstall.packages(\"spData\")  \ninstall.packages(\"spDataLarge\", repos = \"https://geocompr.r-universe.dev\")",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "02-Basic.html",
    "href": "02-Basic.html",
    "title": "1  Basic Geographic",
    "section": "",
    "text": "1.1 벡터(Vector) & 래스터(Raster) 데이터\n벡터와 래스터 데이터는 지리 공간 분석을 위한 두 가지 종류의 데이터로써, 분석 목적에 따라 선택적으로 활용된다.\n1) Vector Data\n벡터 데이터는 점(point), 선(line), 다각형(polygon)을 사용하여 지리적 개체를 표현한다. 따라서 개체의 위치, 형상, 속성 등을 정확하게 기록할 수 있는데, 예를들어, 도로망, 하천, 토지 경계 등 정밀한 위치 정보가 필요한 요소를 표현하는 데 적합하다.\n2) Raster Data\n래스터 데이터는 격자(grid) 형태로 구성되며, 픽셀(pixel) 단위로 지리적 정보를 저장한다. 각 픽셀에는 지형 고도, 토지 이용 분류, 온도와 같은 연속적인 값이나 분류 코드와 같은 이산적인 값이 할당될 수 있다. 영상 이미지와 유사한 구조를 가지며, 위성 이미지나 항공사진등 광범위한 지역의 공간 정보를 시각화하는 데 주로 활용된다.",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basic Geographic</span>"
    ]
  },
  {
    "objectID": "02-Basic.html#벡터vector-래스터raster-데이터",
    "href": "02-Basic.html#벡터vector-래스터raster-데이터",
    "title": "1  Basic Geographic",
    "section": "",
    "text": "Figure 1.1: Vector/Raster Structure\n\n\n\n\n\n\n\n1.1.1 Vector Example\n앞에서 간략하게 벡터 데이터에 대해서 알아보았으니, 코드를 통해서 어떻게 사용하는지 확인해보자.\nlibrary(sf)    # for vector data\nlibrary(terra) # for raster data\nlibrary(dplyr) # for data frame manipulation\n\nlibrary(spData) # for example data\n패키지를 불러왔으면, spData의 world 예시 데이터를 확인해보자.\n\nspData::world # example data\n\nSimple feature collection with 177 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.64513\nGeodetic CRS:  WGS 84\n# A tibble: 177 × 11\n   iso_a2 name_long continent region_un subregion type  area_km2     pop lifeExp\n * &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 FJ     Fiji      Oceania   Oceania   Melanesia Sove…   1.93e4  8.86e5    70.0\n 2 TZ     Tanzania  Africa    Africa    Eastern … Sove…   9.33e5  5.22e7    64.2\n 3 EH     Western … Africa    Africa    Northern… Inde…   9.63e4 NA         NA  \n 4 CA     Canada    North Am… Americas  Northern… Sove…   1.00e7  3.55e7    82.0\n 5 US     United S… North Am… Americas  Northern… Coun…   9.51e6  3.19e8    78.8\n 6 KZ     Kazakhst… Asia      Asia      Central … Sove…   2.73e6  1.73e7    71.6\n 7 UZ     Uzbekist… Asia      Asia      Central … Sove…   4.61e5  3.08e7    71.0\n 8 PG     Papua Ne… Oceania   Oceania   Melanesia Sove…   4.65e5  7.76e6    65.2\n 9 ID     Indonesia Asia      Asia      South-Ea… Sove…   1.82e6  2.55e8    68.9\n10 AR     Argentina South Am… Americas  South Am… Sove…   2.78e6  4.30e7    76.3\n# ℹ 167 more rows\n# ℹ 2 more variables: gdpPercap &lt;dbl&gt;, geom &lt;MULTIPOLYGON [°]&gt;\n\n\nSimple feature collection은 패키지 sf에서 사용될 수 있는 공간 데이터 구조라는 의미이며, 177개의 행과 10개의 열이 있다는 것을 알 수 있다. 그러나, 실제 데이터에서는 11개인데 이는 공간 정보(geometry)를 포함한 결과이다.\nGeometry type은 Multipolygon으로 하나 이상의 폴리곤으로 구성되어있다는 의미이고, 좌표는 XY로 2차원으로 되어있다고 이해하면 된다.\nBounding box는 world데이터가 커버하는 지리적 범위를 보여준다.\nGeodetic CRS, 즉 GPS에서 사용하는 표준 좌표계 WGS 84를 사용하고 있고, 이를 EPSG: 4326으로 나타낼 수 있다.\n\n\n\n\n\n\nNOTE: WGS 84\nWorld Geodetic System 1984 (WGS 84)로 전 세계에서 가장 많이 쓰이는 지리 좌표계.\n좌표형식은 아래와 같음.\n\nX값 = 경도 (longitude) : -180 ~ 180도\nY값 = 위도 (latitude) : -90 ~ 90도\n\n\n\n\n\nst_crs(world)  # check geographic coordinate system\n\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n\n\n\bMetadata of world Dataset (spData)\n\ncolnames(world)\n\n [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"     \n\n\n\n\n\n\n\n\nFeature\nDescription\n\n\n\n\niso_a2\nISO 3166-1 alpha-2 code (e.g., KR = South Korea)\n\n\nname_long\nFull country name\n\n\ncontinent\nGeographic Continent Classification (#6~7)\n\n\nregion_un\nUnited Nations (UN) Regional Classification (#5)\n\n\nsubregion\nDetailed UN region classification (e.g., Eastern Asia, Western Africa)\n\n\ntype\nType of administrative unit (e.g., Sovereign country, Country, Dependency)\n\n\narea_km2\nTotal area of the country in square kilometers\n\n\npop\nPopulation estimate\n\n\nlifeExp\nLife expectancy (years)\n\n\ngdpPercap\nGDP per capita in current US dollars\n\n\ngeom\nGeometry column (MULTIPOLYGON)\n\n\n\n\n\n\n\n\n간략하게 데이터를 확인해보면 다음과 같다.\n\nworld_agg5 &lt;- world |&gt; \n  st_drop_geometry() |&gt;                      # drop the geometry for speed\n  select(pop, continent, area_km2) |&gt;        # subset the columns of interest  \n  \n  group_by(Continent = continent) |&gt;         # group by continent and summarize\n  \n  summarize(Pop = sum(pop, na.rm = TRUE),    # total population\n            Area = sum(area_km2),            # area\n            N = n()) |&gt;                      # total # of countries\n  \n  mutate(Density = round(Pop / Area)) |&gt;     # calculate population density\n  \n  slice_max(Pop, n = 3) |&gt;                   # keep only the top 3\n  arrange(desc(N))                           # arrange in order of n. countries\n\nworld_agg5\n\n# A tibble: 3 × 5\n  Continent        Pop      Area     N Density\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt;\n1 Africa    1154946633 29946198.    51      39\n2 Asia      4311408059 31252459.    47     138\n3 Europe     669036256 23065219.    39      29\n\n\n추가적으로, 지리 데이터에 추가 정보를 더하여 맵을 그려보자.\n\nhead(coffee_data)\n\n# A tibble: 6 × 3\n  name_long                coffee_production_2016 coffee_production_2017\n  &lt;chr&gt;                                     &lt;int&gt;                  &lt;int&gt;\n1 Angola                                       NA                     NA\n2 Bolivia                                       3                      4\n3 Brazil                                     3277                   2786\n4 Burundi                                      37                     38\n5 Cameroon                                      8                      6\n6 Central African Republic                     NA                     NA\n\n\ncoffee_data는 coffee 데이터로, 나라별로 2016년과 2017의 생산량 정보를 가진 데이터다.\n\nworld_coffee &lt;- left_join(world,       # geometry data\n                          coffee_data, # additional data\n                          by = \"name_long\")\n\nplot(world_coffee[\"coffee_production_2017\"])\n\n\n\n\n\n\n\n\n\n\n1.1.2 Raster Example\n다음으로 래스터 데이터는 어떻게 활용되는지 예시와 함께 알아보자.\n벡터 데이터와는 다르게, 래스터 데이터는 연속적인 표면을 보여줄 수 있고, 범주형 표면 또한 보여줄 수 있다.\nRaster with numeric\n다음과 같이 픽셀을 임의로 생성하여, 래스터가 어떻게 작동하고 계산되는지 확인해보자.\n\nelev &lt;- terra::rast(nrows = 6, ncols = 6,\n                    xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                    vals = 1:36)\nelev\n\nclass       : SpatRaster \ndimensions  : 6, 6, 1  (nrow, ncol, nlyr)\nresolution  : 0.5, 0.5  (x, y)\nextent      : -1.5, 1.5, -1.5, 1.5  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nname        : lyr.1 \nmin value   :     1 \nmax value   :    36 \n\n\nelev는 terra패키지로 생성된 SpatRaster데이터로, 6행 6열 레이어 1층 구조이다. 해당 구조는 Figure 1.2 에서 확인 할 수 있다.\n\n\n\nFigure 1.2: Raster Pixel Structure\n\n\n\n\n\n\n해상도 (resolution)는 한 픽셀의 가로세로가 0.5도씩이다.\n래스터 공간 범위를 나타내는 extent는\n\nX축(경도): -1.5 ~ 1.5\nY축(위도): -1.5 ~ 1.5\n\nRaster with categorical values\n반면, 래스터 데이터는 범주형 변수 역시 적용할 수 있다.\n\ngrain_order &lt;- c(\"clay\", \"silt\", \"sand\")\n\ngrain_char &lt;- sample(grain_order, 36, replace = TRUE)\ngrain_fact &lt;- factor(grain_char, levels = grain_order)\n\ngrain &lt;- rast(nrows = 6, ncols = 6, \n             xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n             vals = grain_fact)\n\n픽셀 단위로 토양의 종류를 표시할 수 있지만, 이 경우 픽셀 간의 경계가 실제 토양이 자연스럽게 이어지는 모습을 정확히 표현하지 못할 수 있다.\n\n\n\n\n\n\n\n\n\n\n\n1.1.3 Summary\n정리하자면, 벡터와 래스터는 각기 다른 특성과 구조를 가지며, 분석 목적과 데이터의 성격에 따라 적절히 선택되어야 한다.\nTable 1.1 과 Table 1.2 는 각각 벡터/ 래스터 데이터의 특징, 장단점을 보여준다.\n\n\n\nTable 1.1: Vector vs. Raster\n\n\n\n\n\n\n\n\n\n\n\n벡터 데이터 (Vector Data)\n래스터 데이터 (Raster Data)\n\n\n\n\n데이터 구성\n점 (Point), 선 (Line), 다각형 (Polygon) 등 지리 객체\n격자(Grid) 형태의 픽셀로 구성\n\n\n표현 방식\n각 객체의 좌표(위치), 형상(Shape), 속성(Attributes) 으로 표현\n각 픽셀의 값(Pixel Value)과 해상도(Resolution)로 표현\n\n\n데이터 구조\n지오메트리(Geometry)와 속성 데이터가 결합된 형태\n픽셀 배열(Grid)에 속성 값이 할당된 형태\n\n\n위치 정확도\n실제 위치를 정밀하게 표현 가능 (좌표 기반)\n해상도에 따라 정확도가 달라짐 (낮은 해상도 = 정보 손실 가능)\n\n\n분석 유연성\n네트워크 분석, 버퍼링, 오버레이 등 공간 분석에 적합\n통계적 분석, 분류, 필터링 등 대규모 분석에 적합\n\n\n데이터 크기 및 처리\n상대적으로 가볍고 속성이 명확함\n대용량 데이터 처리에 유리하지만, 해상도가 높을수록 파일 크기 증가\n\n\n\n\n\n\n\n\n\nTable 1.2: Vector/Raster pros & cons\n\n\n\n\n\n\n\n\n\n\n\n장점\n단점\n\n\n\n\n벡터 데이터\n정밀한 기하학적 위치와 속성 정보 제공\n점, 선, 면 등 다양한 형태 지원\n공간 분석 및 속성 기반 질의에 적합\n편집 및 업데이트 용이\n대용량일 경우 저장·처리 부담 증가\n확대·축소 시 형상의 복잡성이 분석에 영향\n연속적인 픽셀 기반 데이터 표현에 부적합\n\n\n래스터 데이터\n대규모 공간 통계 및 영상 처리에 적합\n이미지와 유사한 직관적 표현 가능\n고속 처리와 자동화에 유리\n해상도에 따라 공간 정확도 제한\n기하학적 관계 분석에는 한계\n고해상도일 경우 저장·처리 용량 증가",
    "crumbs": [
      "Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basic Geographic</span>"
    ]
  },
  {
    "objectID": "01-Introduction.html",
    "href": "01-Introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "지리공간 분석에는 주로 Python, QGIS, C, JAVA 등의 프로그램이 활용되지만, R 프로그램 또한 통계 기반의 강점을 바탕으로 유용한 도구로 평가된다. 본 분석에서는 R 프로그램을 이용한 지리공간 분석의 기초를 수행하고자 하며, R을 사용하는 데에는 다음과 같은 장점이 있다.\n\n통합 개발환경(IDE)을 통해 접근성이 뛰어나다.\n다양한 통계 패키지를 쉽게 적용할 수 있어 정량적 분석에 유리하다.\nggplot2와 같은 강력한 시각화 패키지를 통해 지리공간 데이터를 \b효과적으로 표현할 수 있다.\nRcpp, reticulate 등을 통해 C++과 Python의 기능을 통합적으로 활용할 수 있는 확장성을 갖고 있다.\n지리 연산 학습 및 계산 작업, 특히 통계, 모델링 및 시각화에 강력하다.\n\n다음은 R에서 대화형 지도제작 또한 가능하다는 것을 보여준다.\n\nlibrary(leaflet)\n\npopup = c(\"Seoul\", \"Tokyo\", \"Beijing\")\nleaflet() |&gt;\n  addProviderTiles(\"NASAGIBS.ViirsEarthAtNight2012\") |&gt; \n  addMarkers(lng = c(126.9780, 139.6917, 116.4074),\n             lat = c(37.5665, 35.6895, 39.9042),\n             popup = popup)\n\n\n\n\n\n\nEnvironment\n실습의 권장 사항은 R 버전 4.3.2 이상 버전.\n필수 패키지는 아래와 같다.\n# for \ninstall.packages(\"sf\")    # for vector data (points, lines, polygons)\ninstall.packages(\"terra\") # for raster data\n\n# for geographic data\ninstall.packages(\"spData\")  \ninstall.packages(\"spDataLarge\", repos = \"https://geocompr.r-universe.dev\")",
    "crumbs": [
      "Introduction"
    ]
  }
]